*** project structure ***

\ezctx
|__.ezctxrc.json
|__src/
   |__config.type.ts
   |__index.ts
   |__utils/
      |__buildGraph.ts
      |__loadConfig.ts
      |__outputFormatter.ts
      |__stringFormatter.ts
      |__utils.type.ts
      |__visualizeGraph.ts
      |__writeOutput.ts
|__tsconfig.json

*** .ezctxrc.json ***

{
    "ignores": ["dist", "README.md", "LICENSE"]
}

*** config.type.ts ***

// loadConfig.ts
export type Config = {
    chunkSize: number;
    ignores: string[];
    outDir: string;
    outDirSingleEmit: boolean;
    defaultIgnores: boolean;
    outFile: string;
};

*** index.ts ***

#!/usr/bin/env node

import * as fs from "node:fs/promises";
import path from "node:path";
import buildGraph from "./utils/buildGraph.js";
import visualizeGraph from "./utils/visualizeGraph.js";
import writeOutput from "./utils/writeOutput.js";
import loadConfig from "./utils/loadConfig.js";
import outputFormatter from "./utils/outputFormatter.js";
import type { Config } from "./config.type.js";
import type { FileNode } from "./utils/utils.type.js";

try {
    // loads in the configs
    const config: Config = await loadConfig();
    const ignores: string[] = config["ignores"];
    const outDir: string = config["outDir"];
    const outDirSingleEmit: boolean = config["outDirSingleEmit"];
    const outFile: string = config["outFile"];
    const chunkSize: number = config["chunkSize"];

    // builds graph
    let graph: FileNode = await buildGraph(process.cwd(), ignores);

    // creates visualization from the graph
    const visualization: string =
        "*** project structure ***\n\n" + visualizeGraph(graph) + "\n";

    // creates output directory; removes previous ones
    const finalOutDir: string = path.join(process.cwd(), outDir);
    await fs.rm(finalOutDir, { recursive: true, force: true });
    await fs.mkdir(finalOutDir, { recursive: true });

    // creates output path;
    const finalOutPath: string = path.join(finalOutDir, outFile);
    // creates path of the first output file
    const firstFinalOutPath: string = outputFormatter(finalOutPath, 1);

    // writes the visualization to the first output file
    await fs.writeFile(firstFinalOutPath, visualization, {
        flag: "w+",
    });

    // count object to access number of output files
    // from outside the writeOutput function
    const count: { count: number } = { count: 1 };
    // adds file contents to output
    await writeOutput(graph, finalOutPath, chunkSize, count);

    // creates path for single emits
    const singleEmitOutPath: string = path.join(
        process.cwd(),
        path.basename(firstFinalOutPath)
    );
    // detects if only a single output file and emits it
    // in the working directory instead of the outDir
    if (count.count === 1 && !outDirSingleEmit) {
        // creates path of the first output file for single emits
        await fs.rename(firstFinalOutPath, singleEmitOutPath);
        await fs.rm(finalOutDir, { recursive: true, force: true });
    } else {
        await fs.rm(singleEmitOutPath, { force: true });
    }
} catch (error) {
    if (error instanceof Error) {
        console.log(error.message);
    } else {
        console.log(error);
    }
    process.exit(1);
}

*** buildGraph.ts ***

import * as fs from "node:fs/promises";
import path from "node:path";
import type { FileNode } from "./utils.type.js";

/**
 * Recursively constructs a graph of the project starting from the path
 * given by dirPath.
 *
 * @param dirPath Path where the graph should start
 * @param ignores Directories/filters to ignore
 * @param maxDepth Max depth to recurse to prevent infinite recursion
 * @param depth Current depth
 * @returns FileNode object
 */
export default async function buildGraph(
    dirPath: string,
    ignores: string[] = [],
    maxDepth: number = 1000,
    depth: number = 0
): Promise<FileNode> {
    // gets name of directory/file
    const name: string = path.basename(dirPath);

    // get stats about directory/file
    const stats = await fs.stat(dirPath);

    // creates a new node
    const fileNode: FileNode = {
        name,
        path: dirPath,
        type: stats.isDirectory() ? "directory" : "file",
        depth,
        size: stats.size,
    };

    // recursively adds children nodes
    if (stats.isDirectory() && depth < maxDepth) {
        // gets all the files/directories within the current one
        const entries: string[] = await fs.readdir(dirPath);

        // filter out ignores files/directories
        let filteredEntries: string[] = entries.filter(
            (entry) => !ignores.includes(entry)
        );

        // add sub-directories and their files
        // as a children property to the parent node
        fileNode.children = await Promise.all(
            filteredEntries.map((entry) =>
                buildGraph(
                    path.join(dirPath, entry),
                    ignores,
                    maxDepth,
                    depth + 1
                )
            )
        );
    }

    return fileNode;
}

*** loadConfig.ts ***

import fs from "node:fs/promises";
import type { Config } from "../config.type.js";
import outputFormatter from "./outputFormatter.js";

// default ignores
const _defaultIgnores: string[] = [
    "node_modules",
    "package-lock.json",
    "package.json",
    ".git",
    ".gitignore",
    ".DS_Store",
    ".vscode",
];

// default config
const defaultConfig: Config = {
    chunkSize: Infinity,
    defaultIgnores: true,
    ignores: _defaultIgnores,
    outDir: "ezctx",
    outDirSingleEmit: false,
    outFile: "ezctx_{i}.txt",
};

/**
 * Loads in the user's config and merges it with default config
 * to fill undefined fields. Assumes the user's config is in the
 * same directory as process.cwd(), contains "ezctx", and is a JSON file.
 *
 * @returns Config
 */
export default async function loadConfig(): Promise<Config> {
    // searches for a user-defined config
    let userConfig: Partial<Config>;
    const userConfigName: string | undefined = (
        await fs.readdir(process.cwd())
    ).find((file) => file.includes("ezctx"));

    if (userConfigName) {
        userConfig = JSON.parse(await fs.readFile(userConfigName, "utf-8"));
    } else {
        userConfig = defaultConfig;
    }

    // merges the program's default ignores with
    // the user-defined ignores

    // stores the merged ignores
    let mergedIgnores: string[];

    if (userConfig.defaultIgnores === undefined || userConfig.defaultIgnores) {
        mergedIgnores = [..._defaultIgnores, ...(userConfig.ignores || [])];
    } else {
        mergedIgnores = [...(userConfig.ignores || [])];
    }

    // add program's output directory and output file to ignores
    // to prevent duplicate writes
    mergedIgnores.push(userConfig.outDir || defaultConfig.outDir);
    mergedIgnores.push(
        userConfig.outFile
            ? outputFormatter(userConfig.outFile, 1)
            : outputFormatter(defaultConfig.outFile, 1)
    );

    // creates merged config
    const mergedConfig: Config = {
        ...defaultConfig,
        ...Object.fromEntries(
            Object.entries(userConfig).filter(
                ([_, value]) => value !== undefined
            )
        ),
        ignores: mergedIgnores,
    };

    return mergedConfig;
}

*** outputFormatter.ts ***

import path from "node:path";

/**
 * Takes in a path or file and embeds the current file count
 * within the output file defined in the config. If the raw
 * output file does not define a place to embed the count, this
 * program defaulty adds "_{count}" before the file name.
 *
 * @param outFile The raw output file format defined in the config
 * @param count The nth output file that is being created
 * @returns A formatted path/file name with the count embedded
 */

export default function outputFormatter(
    outputPath: string,
    count: number
): string {
    // extracts the file name
    const fileName = path.basename(outputPath);
    // extracts the file dirname
    const dirName = path.dirname(outputPath);
    // gets index of the section to replace with the
    // current file count
    const index = fileName.indexOf("{i}");

    if (index == -1) {
        // if not defined, add default count
        const fileNameParts = fileName.split(".");
        const finalOutputFile =
            fileNameParts[0] + `_${count}.` + fileNameParts[1];
        return path.join(dirName, finalOutputFile);
    }

    // otherwise, replace the {i} with the current file count
    const finalOutputFile =
        fileName.substring(0, index) + count + fileName.substring(index + 3);
    return path.join(dirName, finalOutputFile);
}

*** stringFormatter.ts ***

/**
 * Formats a given resource by adding spacing and lines
 * to ensure that it is properly placed when creating a
 * visualization of the project's structure
 *
 * @param depth Current depth within the graph
 * @param name Name of the file/directory
 * @param type Type of the given resource
 * @returns A formatted string of the resource
 */

export default function stringFormatter(
    depth: number,
    name: string,
    type: "directory" | "file"
): string {
    return depth == 0
        ? `\\${name}\n`
        : `   `.repeat(depth - 1) +
              `|__${name}${type === "directory" ? "/" : ""}\n`;
}

*** utils.type.ts ***

// buildGraph.ts, visualizeGraph.ts
export type FileNode = {
    name: string;
    path: string;
    type: "directory" | "file";
    size: number;
    depth: number;
    children?: undefined | FileNode[];
};

*** visualizeGraph.ts ***

import type { FileNode } from "./utils.type.js";
import stringFormatter from "./stringFormatter.js";

/**
 * Recursively creates a visualization of the project's graph.
 * Uses stringFormatter.ts to format each directory/file
 *
 * @param graph Project's graph
 * @param output Store's recursive output
 * @returns A visualization of the given graph
 */

export default function visualizeGraph(
    graph: FileNode | FileNode[] | undefined,
    output: string = ""
): string {
    // if graph is undefined, reach end/tip
    if (!graph) return output;

    // if not array, it's the root or a child within an array
    if (!Array.isArray(graph)) {
        output += stringFormatter(graph.depth, graph.name, graph.type);
        output = visualizeGraph(graph.children, output);
    } else {
        graph.forEach((child) => {
            output += stringFormatter(child.depth, child.name, child.type);
            output = visualizeGraph(child.children, output);
        });
    }

    return output;
}

*** writeOutput.ts ***

import * as fs from "node:fs/promises";
import type { FileNode } from "./utils.type.js";
import outputFormatter from "./outputFormatter.js";

/**
 * Recursively adds content to the output files while ensuring
 * that the size of each output file is less than the given chunkSize.
 * If it is, it starts a new output file with the file namen given in
 * outputPath. Stores the count as an object to have it persist.
 *
 * @param graph Project's graph
 * @param outputPath The path to write output to
 * @param chunkSize The max size of each output file
 * @param count The count of the current output file
 */

export default async function writeOutput(
    graph: FileNode | FileNode[] | undefined,
    outputPath: string,
    chunkSize: number,
    count: { count: number }
): Promise<void> {
    // if graph is null/undefined, reach tip
    if (!graph) return;

    // turn current node into array to handle empty directories
    const nodes = Array.isArray(graph) ? graph : [graph];

    // recursively adds each nodes' file content to the output
    for (const node of nodes) {
        if (node.type === "directory") {
            await writeOutput(node.children, outputPath, chunkSize, count);
        } else if (node.type === "file") {
            // get file's content and add formatting
            const content =
                "*** " +
                node.name +
                " ***" +
                "\n\n" +
                (await fs.readFile(node.path)) +
                "\n";
            // get the correct output path 
            let currentOutputPath = outputFormatter(outputPath, count.count);
            // get the size of the current content
            const contentSize = Buffer.byteLength(content, "utf-8");
            // try-catch block because the currentOutputPath may not exist on disk
            // ie. first time writing to this output file
            try {
                // get size of current output file
                const { size } = await fs.stat(currentOutputPath);

                // if the size of the current content is bigger
                // than chunk size, skip file
                if (contentSize > chunkSize) return;

                // ensures that the chunkSize condition is respected
                if (size > 0 && contentSize + size > chunkSize) {
                    currentOutputPath = outputFormatter(outputPath, ++count.count);
                }
            } catch (error) {}

            await fs.writeFile(currentOutputPath, content, { flag: "a" });
        }
    }
}

*** tsconfig.json ***

{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    "rootDir": "./src",
    "outDir": "./dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "nodenext",
    "target": "esnext",
    // "types": [],
    // For nodejs:
    "lib": ["esnext"],
    "types": ["node"],
    // "noEmit": true,
    // and npm install -D @types/node

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    "noImplicitReturns": true,
    // "noImplicitOverride": true,
    "noUnusedLocals": false,
    "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    // "jsx": "react-jsx",
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
  }
}

